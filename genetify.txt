Using genetify on your webpage
==============================

Loaded in a webpage, genetify.js lets you create _experiments_ in your code.
Each experiment tests a group of alternatives and chooses the best one.

Genetify.js works with groups of CSS rules, javascript variables and HTML
tags. The groups are defined implicitly by adding special suffixes like "_vBeta"
to an object's original name.

Experiments are evaluated by user feedback. Any kind of user interaction can
be turned into a _goal_ of an experiment by using standard DOM events.

The aim of genetify.js was to make the programming of code experiments as
natural as possible.

Terminology
-----------

Groups of CSS rules, javascript variables or HTML tags whose members are meant
to be tested on users will be called _genes_, inspired by the unit of
selection in biological evolution.

The members of those groups will be called _variants_ because they should each
vary one from the other in some purposeful way.

To say that something is _genetified_ is to say that it has been branched off
into multiple variants and is ready to be tested.

Installation
------------

Insert a style tag into the head of a HTML document.

<pre>
    <style type="text/css" media="screen"> 
        .v { display: none; }
        .genetify_disabled { display: none !important; } 
        .genetify_enabled { display: block !important; } 
    </style>
</pre>

These CSS rules are important because they ensure that variants are not
displayed if genetify.js fails to load or execute.

Below the style tag, insert a script tag referencing genetify.js.

<pre>
    <script type="text/javascript" src="genetify.js"></script>
</pre>

Genetify.js must be loaded *before* any other javascript upon which it is
supposed to act, so typically it should be inserted as the first script tag in
the head. As a small optimization, you could put it below any scripts you know
will not be genetified.

At the bottom of the page, just before the </body> tag, insert a script tag
that calls the main function of genetify.

<pre>
    <script type="text/javascript">
        genetify.vary();
    </script>
</pre>
    
Defining genes
--------------

This is the fun part. To make a new gene, you simply branch off some existing
object and add a suffix to the new object. It is easiest to learn by example:

<pre>
    #navbar { color: red; }
    #navbar_vA { color: green; }
</pre>

The original CSS rule here can be branched off infinitely.

<pre>
    #navbar { color: red; }
    #navbar_vA { color: green; }
    ...
    #navbar_vZZZ { color: chartreuse; }
</pre>

The suffix can take one of several forms, depending on the type of code of the
gene being defined.

As seen above, CSS rules take a underscore "_" followed by "v" and the variant
name. The other type of CSS gene, an additive rule, takes a "." instead of a
"_", as in:

<pre>
    #navbar { color: red; }
    #navbar.vGreen { background-color: green; }
</pre>

The functional differences between these two types are explained in the
section _How genes are varied_.

Javascript variables are genetified in the same way as CSS Rules. For example:

<pre>
    highlight = function(elem){
        elem.style.borderColor = 'green';
    }
    highlight_vRed = function(elem){
        elem.style.borderColor = 'red';
    }
</pre>

HTML elements are genetified like this:

<pre>
    <div class="sentence">One way of saying something</div>            
    <div class="sentence v anotherway">Another way of saying something</div>          
</pre>

The reason for the separate "v" class is because HTML elements have an effect
on the user by default (by being shown on screen) unlike an unused chunk of
javascript or CSS. The "v" class lets genetify hide variants until they are
switched on. A class name to the left of "v", "sentence" in this example, must
be present to group elements together into a gene. Multiple genes can then
coexist on the same page.

<pre>
    <div class="sentence">One way of saying something</div>            
    <div class="sentence v anotherway">Another way of saying something</div>            

    <div class="sentence2">Qu'est-ce qu'il dit?</div>            
    <div class="sentence2 v anotherway">Je ne sais pas.</div>          
</pre>

The common naming scheme across all types of genes is:

<pre>
    GeneName + VariantMarker + VariantName
</pre>

How genes are varied
--------------------

On an abstract level, genes comprised of CSS rules and javascript variables
are handled the same way. One of the variants (including the original) is
randomly chosen and the original name is then reassigned to the chosen
variant. This has the effect of putting the variant object in the place of the
original object wherever the original object is referenced.

Genes that are comprised of additive CSS rules are handled somewhat
differently. Instead of an original CSS rule being overwritten, the chosen
variant is added as a class to HTML elements that match the rest of the
selector. Take this simplified document as an example.

<pre>
    #navbar { color: red; }
    #navbar.vGreen { background-color: green; }

    <div id="navbar">lalalalala</div>          
</pre>

Assuming variant Green is chosen, "vGreen" will be added to the className property of
element navbar, causing it to inherit the background-color specified in the
rule. The advantage of additive CSS genes over plain CSS genes is that
variants need only contain the *difference* between them and the original CSS
rule. With plain CSS rules, the same effect would be achieved by:

<pre>
    #navbar { color: red; } 
    #navbar_vGreen { color: red; background-color: green; }
</pre>

Finally, element genes are varied by adding the special CSS classes
"genetify_enabled" or "genetify_disabled" to variants. As explained above,
properly named element genes have all variants hidden to start with except the
designated default.

Note that applying "genetify_enabled" to elements whose default display
property is not "block" may cause trouble. Read below for a simple workaround. 

Defining goals
--------------

This is the other fun part. To genetify.js, a _goal_ is the calling of a
special function, genetify.record.goal, that sends a request to the genetify
server. The request contains information on the goal and gene variants that
have been selected on the site. Each goal must be given a name and a value.

<pre>
    genetify.record.goal('nirvana', 100);
</pre>

Typically, you'll want to call genetify.record.goal after a DOM event. For
instance, as the onclick handler of a link.

<pre>
    <a href="#" onmousedown="genetify.record.goal('score', 2);">score!</a>
</pre>

Another common case is a call at the bottom of a page in order to record a
pageview.

<pre>
    <script type="text/javascript">
        genetify.record.goal('pageview', 1);
    </script>
</pre>

The name of a goal can be any string less than 255 characters. The value of a
goal can be any positive number. The value affects the relative weight of a
goal when multiple goals exist on a single site.

How goals influence genes
-------------------------

The point of recording goals is to influence the selection of variants. As
explained above, recording a goal sends information to a remote server. The
remote server aggregates such information and calculates which variants led to
which goals.

Results come back to a genetified page when it loads. When genetify.js
initializes, it makes a request for a JSON file keyed on the current domain
and page. The JSON file contains information on each variant in the page and
its history of producing goals.

When a gene is varied, genetify.js checks the fetched results for information
about that gene's variants. When present, this information influences the
probability that each variant is selected. Variants that have led to more
goals in the past will be selected more frequently -- variants that have led
to fewer goals will be selected less frequently. In this way, genes adapt to
user feedback.
     

Appendices
==========

Testing your installation
-------------------------

Here is a useful sequence for testing genetify.js on a page.

1. Check for javascript errors. Genetify.js performs checks on load.

2. Set GENETIFY_CONFIG = { USE_COOKIE: false, LOAD_CONTROLS: true } . Read
about configuration options below.

3. Add GeneName + VariantMarker + VariantName markup to a minimal subset of
things you want to vary.

4. Call genetify.vary or use control panel and check for errors.

5. Observe all your expected variants by repeatedly varying the page. Note
that by default genetify will maintain state for a single visitor (USE_COOKIE
= true).

6. Add a goal (or use control panel) and call it repeatedly for one variant of
a gene. You should observe a change in frequency of that variant over page
loads.

7. Add GeneName + VariantMarker + VariantName markup to the remaining things
you want to vary.

Configuration options
---------------------

Genetify.js will read in certain configuration options in the global variable
"GENETIFY_CONFIG" when it first loads. Names and descriptions are below.
Defaults are values shown.

<pre>
    GENETIFY_CONFIG = {       
        
        // Request remote script that contains results for variants in the
        // current page. 
        REQUEST_RESULTS: true,
        
        // Request results as a static file from a cache on the server.
        USE_RESULTS_CACHE: true,
        
        // Force current genes to variants previously viewed by visitor.
        // Useful for ensuring a consistent user experience.
        USE_COOKIE: true,                               

        // Namespace in which encountered genes are placed. Useful for
        // treating genes on different pages as a single unit.
        NAMESPACE: window.location.pathname,
        
        // Skip all initialization for varying genes. Useful on pages with
        // goals but no genes.
        NO_VARYING: false,       
        
        // Load graphical control panel for testing.
        LOAD_CONTROLS: false
        
    }
</pre>

Goals on different pages than genes
-----------------------------------

Goals can be recorded on any page, even one without genes. Information about
genes on a page is written into a cookie when genetify.vary is called. When
genetify.record.goal is subsequently called anywhere on the same domain, the
information in the cookie will be read out.

Showing/hiding non-block elements
---------------------------------

The special CSS class "genetify_enabled" specifies the display mode of
genetified HTML elements throughout the page. By default, it is set to
"display: block". If you want to display genetified elements as "inline" or in
some other mode, you can simply change the "genetify_enabled" rule.

<pre>
    .genetify_enabled { display: inline; }
</pre>

This would cause selected variants to display in "inline" mode. Alternatively,
you could leave the default as "block" and make only spans display "inline".

<pre>
    .genetify_enabled { display: block; }    
    span.genetify_enabled { display: inline; }         
</pre>

Grouping elements as a single variant
-------------------------------------

Genetify allows multiple elements to switched on and off as a single variant.
A group of elements are denoted as a single variant in a natural way:

<pre>
    <div class="emotion v happy"> :-D </div>            
    <div class="emotion v sad"> :-( </div>            
    <div class="emotion v happy"> I'm happy </div>            
    <div class="emotion v sad"> I'm sad </div>
</pre>

In this example, the happy and sad emoticons will be paired with the
appropriate text. Note that the other types of variants -- additive CSS rules,
CSS rules and javascript -- may affect multiple HTML elements by their
inherent operation.

Calling for one type of gene
----------------------------

It is possible to call genetify.vary for only a specific type of gene. This
might be useful for optimizing peformance or avoiding buggy interactions. The
calls are:

<pre>
    genetify.vary('javascript');           
    genetify.vary('CSSRules');
    genetify.vary('elements');
    genetify.vary('additiveCSSRules');
</pre>

It is also possible to call for multiple types. 

<pre>
    genetify.vary('javascript', 'CSSRules');         
</pre>
    
Calling at will
---------------

Advanced users should know that it is possible to successfully call
genetify.vary from different stages of a normal page load. The important point
is that all the code that genetify is to operate on has already loaded.

The specific rules to follow are:

<pre>
    // Must come before all script tags that load genetified javascript,
    // likely somewhere in the head 
    genetify.vary('javascript');
    
    // Must come after all genetified CSS rules have been declared, likely at
    // the bottom of the head 
    genetify.vary('CSSRules');

    // Must come after all genetified elements, likely at the bottom of page
    // or after onload event has fired 
    genetify.vary('elements');

    // Must come after all elements referred to by genetified CSS rules,
    // likely at the bottom of page or after onload event has fired
    genetify.vary('additiveCSSRules');
</pre>

At times it may even be desirable to call genetify.vary outside of a normal
page load, maybe after an AJAX request. The function should always act on
whatever genes are accessible when called, but switching variants after
default variants have lingered onscreen may surprise the user.

Onscreen flickering
-------------------

Because of the immediate rendering of content by browsers, calling
genetify.vary late in the page load process can cause an apparent flicker
onscreen as the original variant of a gene is switched for another variant. A
simple and effective solution to this problem is to put the call to
genetify.vary as early as possible. For example:

<pre>
    <div class="sentence">One way of saying something</div>            
    <div class="sentence v anotherway">Another way of saying something</div>            
    <script type="text/javascript">
        genetify.vary();
    </script>
</pre>
    
Performance
-----------

With all the scanning of namespaces, it is fair to ask how genetify affects
page load performance. Based on real world data across all browsers,
initializing genetify.js takes on average about 70 miliseconds, while
executing genetify.vary takes on average 30ms.

Performance depends most strongly on the size of the underlying namespaces
being searched -- the numbers of CSS rules, HTML elements or javascript
objects. In most cases, performance can be improved substantially by
restricting the search to only those namespaces that are known to contain
genes. See the section "Calling at will" above. On pages where no genes exist
(typically when genetify.js is needed only to record a goal) most
initialization time can be skipped by specifiying "NO_VARYING" as a
configuration option.

Warning: Internet Explorer
--------------------------

Genetify.vary does not work the same way for external javascript in Internet
Explorer.

It seems that although IE registers global variables in the window object as
it should, it does not include them in the window object when iterating over
it, so genetify can't necessarily access all javascript variables. As a
workaround, it scans the contents of all script tags on the page for variable
names, and then it traverses the namespaces of what it finds.

The takeaway message is that a genetified javascript variable *or* one of its
parents must be referenced in the contents of a script tag in the current page
for it to be found. For example:

<pre>
    <script type="text/javascript" src="mystuff.js"></script>
</pre>

Nothing in mystuff.js will be found unless somewhere on the same page is
written a reference to some object from mystuff.js:

<pre>
    <script type="text/javascript">
        mystuff.dosomestuff();
    </script>
</pre>    

If "mystuff" is the root object to everything in mystuff.js, then
genetify.vary will work perfectly in IE. 

Genetify has been tested and runs well in other major browsers.